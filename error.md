# 黑白棋遊戲 - 設計與錯誤歷程

這份文件記錄了在開發這個黑白棋遊戲過程中遇到的一些挑戰、設計決策以及修正的錯誤。

## 1. 棋子翻轉邏輯的複雜性

**問題描述**：
初版設計時，翻轉棋子的邏輯非常複雜且容易出錯。一開始嘗試在每次點擊時，從該點向八個方向進行 `while` 迴圈掃描，找到對手棋子後再向同方向尋找自己的棋子，如果找到就執行翻轉。這個過程在單一函式中顯得非常臃腫。

**解決方案**：
將邏輯拆分為更小的函式：
1.  建立一個 `getFlippablePieces(row, col, player)` 函式，專門用來檢查某個落子點是否有效，並回傳所有可以被翻轉的棋子座標陣列。
2.  這個函式內部遍歷八個方向。對於每個方向，它會：
    a. 沿該方向尋找連續的對手棋子。
    b. 如果在找到對手棋子後，最終遇到自己的棋子，則將這條線上的對手棋子標記為可翻轉。
3.  在主點擊事件 `handleCellClick` 中，先呼叫 `getFlippablePieces`。如果回傳的陣列長度大於 0，代表此處為有效落子，然後才執行落子與翻轉的動作。

這個重構讓程式碼更清晰，也更容易除錯。

## 2. 遊戲結束條件判斷不完整

**問題描述**：
最初只考慮了「棋盤下滿」作為遊戲結束的條件。但在實際遊戲中，常常會出現雙方都無棋可下的情況，導致遊戲卡住。

**解決方案**：
在每次切換玩家 `switchPlayer` 時，加入更完整的結束判斷：
1.  切換到下一位玩家後，立刻檢查該玩家是否有任何合法落子點（透過 `hasValidMoves(player)` 函式）。
2.  如果沒有 (`false`)：
    a. 彈出提示，告知該玩家無棋可下，跳過回合。
    b. **再次切換回原玩家**，並再次呼叫 `hasValidMoves()` 檢查。
    c. 如果這位玩家也無棋可下，代表**雙方都無法動彈**，此時才觸發 `endGame()` 函式，正式結束遊戲。

這個雙重檢查確保了遊戲不會在一方暫時無棋可下時就提前結束。

## 3. 狀態更新與畫面渲染不同步

**問題描述**：
在翻轉棋子後，有時分數的更新或棋盤畫面的重繪會比預期慢，或者在遊戲結束的 `alert` 彈出時，棋盤還沒更新到最終狀態。

**解決方案**：
1.  **統一渲染流程**：確保所有改變 `board` 陣列狀態的操作（如落子、翻轉）都只更新資料模型。然後統一呼叫 `renderBoard()` 和 `updateInfo()` 來根據最新的資料模型重繪整個 UI。這避免了直接操作 DOM 元素導致的狀態不一致。
2.  **使用 `setTimeout`**：對於遊戲結束的提示，使用 `setTimeout(() => alert(message), 100);`。給予瀏覽器一個極短的時間（例如 100 毫秒）來完成 DOM 的重繪，然後再彈出 `alert` 視窗。這樣可以確保玩家看到的是最終的棋盤和分數，然後才看到結束訊息。

## 4. 初始棋盤狀態錯誤

**問題描述**：
在黑白棋規則中，中央的四個棋子是交錯放置的。初版程式碼不小心將顏色放反或放在了錯誤的位置（例如 `[3][3]` 和 `[4][4]` 都是黑色），導致遊戲無法正常開始。

**解決方案**：
仔細核對黑白棋的標準開局規則，並在 `initializeGame` 函式中修正初始棋盤的狀態：
- `board[3][3] = WHITE;`
- `board[3][4] = BLACK;`
- `board[4][3] = BLACK;`
- `board[4][4] = WHITE;`

這個看似微小的錯誤對整個遊戲體驗有巨大影響，修正後確保了遊戲的公平性和正確性。
